#include <stdio.h>
#include <string.h>

#include "parser.h"
#include "tokens.h"
#include "der_encode.h"
#include "utils.h"

/*
 * lexer functions we need to provide
 */

int yylineno = 1;

void
yyerror(const char *str)
{
	fprintf(stderr, "Error: %s at line %d\n", str, yylineno);
}

int
yywrap(void)
{
	return 1;
}

/*
 * parser helper functions
 */

struct node *
add_child(struct node *parent, uint32_t asn1tagclass)
{
	struct node *child = safe_malloc(sizeof(struct node));

	/* class is in the top 8 bits, tag is the bottom 24 bits */
	child->asn1tag = asn1tagclass & 0xffffff;
	child->asn1class = (asn1tagclass >> 24) & 0xff;
	child->length = 0;
	child->value = NULL;
	child->children = NULL;
	child->siblings = NULL;

	/* is it the first */
	if(parent->children == NULL)
	{
		parent->children = child;
	}
	else
	{
		/* add it to the end of the siblings list */
		struct node *sib = parent->children;
		while(sib->siblings != NULL)
			sib = sib->siblings;
		sib->siblings = child;
	}

	return child;
}

/*
 * return true if any of the node's descendants are not synthetic
 */

bool
has_real_children(struct node *n)
{
	struct node *kid;

	for(kid=n->children; kid; kid=kid->siblings)
	{
		if(has_real_children(kid) || !is_synthetic(kid->asn1tag))
			return true;
	}

	return false;
}

/*
 * parser functions for the predefined types
 */

void parse_BOOLEAN(struct node *parent)
{
	if(next_token() != BOOLEAN)
		parse_error("Unexpected token '%s'; expecting 'true' or 'false'", token_text());

	verbose("<BOOLEAN value=%s/>\n", token_text());

	der_encode_BOOLEAN(&parent->value, &parent->length, strcmp(token_text(), "false"));

	return;
}


void parse_INTEGER(struct node *parent)
{
	if(next_token() != INTEGER)
		parse_error("Unexpected token '%s'; expecting an integer", token_text());

	verbose("<INTEGER value=%s/>\n", token_text());

	der_encode_INTEGER(&parent->value, &parent->length, strtol(token_text(), NULL, 0));

	return;
}

void parse_STRING(struct node *parent)
{
	if(next_token() != STRING)
		parse_error("Unexpected token '%s'; expecting \"STRING\"", token_text());

	verbose("<STRING value=%s/>\n", token_text());

	der_encode_OctetString(&parent->value, &parent->length, token_text());

	return;
}


void parse_QPRINTABLE(struct node *parent)
{
	if(next_token() != QPRINTABLE)
		parse_error("Unexpected token '%s'; expecting 'QPRINTABLE'", token_text());

	verbose("<QPRINTABLE value=%s/>\n", token_text());

	der_encode_OctetString(&parent->value, &parent->length, token_text());

	return;
}


void parse_BASE64(struct node *parent)
{
	if(next_token() != BASE64)
		parse_error("Unexpected token '%s'; expecting `BASE64`", token_text());

	verbose("<BASE64 value=%s/>\n", token_text());

	der_encode_OctetString(&parent->value, &parent->length, token_text());

	return;
}


void parse_Null(struct node *parent)
{
	if(next_token() != Null)
		parse_error("Unexpected token '%s'; expecting 'Null'", token_text());

	verbose("<Null/>\n");

	/* assert */
	if(parent->length != 0)
		fatal("Null: length=%u", parent->length);

	return;
}

/*
 * auto-generated parser functions follow
 */

